# External Libraries
import pytest
import pandas as pd
import numpy as np

# Importing from our library
from ...finml_core.metrics.indicators import (
    bollinger_bands, rsi, macd, relative_volume
)

# --- FIXTURES (Test Data) ---
@pytest.fixture
def sample_prices():
    return pd.Series([100.0, 102.0, 104.0, 106.0, 108.0])

def test_bollinger_bands_structure(sample_prices):
    """Verifies that the output contains the expected rows and column names."""
    df = bollinger_bands(sample_prices, window=2)
    
    expected_cols = ['middle_band', 'upper_band', 'lower_band', 'percent_b', 'bandwidth']
    assert list(df.columns) == expected_cols
    assert len(df) == 5

# --- TESTS ---
def test_bollinger_bands_calculation(sample_prices):
    """Tests band calculation logic with a minimal window."""
    # Window = 2. Index 1 (values: 100, 102).
    # Mean = 101.
    # Std (sample) = sqrt(((100-101)^2 + (102-101)^2)/(2-1)) = sqrt(2) â‰ˆ 1.4142
    # Upper (k=2) = 101 + (2 * 1.4142) = 103.8284
    # Lower (k=2) = 101 - (2 * 1.4142) = 98.1716
    
    df = bollinger_bands(sample_prices, window=2, num_std=2.0)
    
    # Check index 1
    mean = 101.0
    std = np.sqrt(2)
    upper = mean + (2 * std)
    lower = mean - (2 * std)
    
    assert df['middle_band'].iloc[1] == pytest.approx(mean)
    assert df['upper_band'].iloc[1] == pytest.approx(upper)
    assert df['lower_band'].iloc[1] == pytest.approx(lower)

def test_derived_metrics_logic(sample_prices):
    """Tests logic for derived metrics (%B and Bandwidth)."""
    # Using same values from previous test for index 1.
    # Price = 102.
    # Lower = 98.1716, Upper = 103.8284
    
    df = bollinger_bands(sample_prices, window=2, num_std=2.0)
    
    price = 102.0
    middle = df['middle_band'].iloc[1]
    lower = df['lower_band'].iloc[1]
    upper = df['upper_band'].iloc[1]
    
    # 1. Test %B: (Price - Lower) / (Upper - Lower)
    expected_pb = (price - lower) / (upper - lower)
    assert df['percent_b'].iloc[1] == pytest.approx(expected_pb)

    # 2. Test Bandwidth: (Upper - Lower) / Middle
    expected_bw = (upper - lower) / middle
    assert df['bandwidth'].iloc[1] == pytest.approx(expected_bw)

def test_rsi_bounds():
    """Verifies that RSI values stay within the [0, 100] range."""
    # Random walk data
    np.random.seed(42)
    prices = pd.Series(np.random.randn(100) + 100)
    
    result = rsi(prices, period=14)
    
    # Drop initial NaNs generated by the lookback period
    clean_result = result.dropna()
    
    assert clean_result.min() >= 0
    assert clean_result.max() <= 100

def test_rsi_trend_logic():
    """Verifies that RSI reacts correctly to clear trends."""
    # 1. Strong Uptrend -> High RSI
    uptrend = pd.Series(np.linspace(100, 200, 50))
    rsi_up = rsi(uptrend, period=14)
    # Should be overbought (>70) at the end
    assert rsi_up.iloc[-1] > 70

    # 2. Strong Downtrend -> Low RSI
    downtrend = pd.Series(np.linspace(200, 100, 50))
    rsi_down = rsi(downtrend, period=14)
    # Should be oversold (<30) at the end
    assert rsi_down.iloc[-1] < 30

def test_macd_structure(sample_prices):
    """Verifies that MACD returns the correct DataFrame structure."""
    df = macd(sample_prices, fast=2, slow=5, signal=2)
    
    expected_cols = ['macd_line', 'signal_line', 'histogram', 'macd_norm']
    assert list(df.columns) == expected_cols
    assert len(df) == len(sample_prices)

def test_macd_logic():
    """Verifies MACD behavior on a clear trend reversal."""
    # Create a V-shape price pattern: Drops then Rises
    # Prices: 10, 9, 8, ... 1, 2, 3 ... 10
    down = np.arange(10, 0, -1)
    up = np.arange(1, 11)
    prices = pd.Series(np.concatenate([down, up]))
    
    # We use small windows to detect the change quickly in this short array
    df = macd(prices, fast=2, slow=5, signal=2)
    
    # 1. Check Downtrend (Negative MACD)
    # We check index 5 instead of 3 to allow for 'min_periods' warmup if present.
    # At index 5, price is 5 (down from 10), so trend is clearly down.
    assert df['macd_line'].iloc[5] < 0

    # 2. Check Uptrend (Positive MACD)
    # At the end (index -1), price is 10 (up from 1), so trend is clearly up.
    # Fast EMA > Slow EMA -> MACD > 0
    assert df['macd_line'].iloc[-1] > 0
    
    # 3. Verify Normalization calculation
    last_price = prices.iloc[-1]
    last_hist = df['histogram'].iloc[-1]
    
    # If using normalize=True (default), check column exists and value matches
    if 'macd_norm' in df.columns:
        expected_norm = last_hist / last_price
        assert df['macd_norm'].iloc[-1] == pytest.approx(expected_norm)

def test_relative_volume_logic():
    """Verifies RVol calculation on a simple scenario."""
    # Scenario: Volume is constant (100) for 19 days, then spikes to 200.
    # Window = 20.
    # The SMA at day 20 (index 19) will be slightly higher than 100 because of the 200,
    # but strictly speaking, let's test a stable case first.
    
    vol = pd.Series([100.0] * 20)
    result = relative_volume(vol, window=20)
    
    # If volume is constant, average is constant, so Ratio should be 1.0
    assert result.iloc[-1] == pytest.approx(1.0)

    # Case 2: Double volume
    # SMA of [100, 100... 100] is 100.
    # Current vol is 200. Result should be ~1.905.
    # We cheat slightly: we pass a constant series for SMA calculation mentally
    # but here we just check the math of the last element manually.
    
    vol_spike = pd.Series([100.0] * 19 + [200.0])
    rvol = relative_volume(vol_spike, window=20)
    
    # SMA calculation: (19*100 + 200) / 20 = 2100 / 20 = 105
    expected_sma = 105.0
    expected_rvol = 200.0 / expected_sma
    
    assert rvol.iloc[-1] == pytest.approx(expected_rvol)

def test_relative_volume_zero_division():
    """Verifies that epsilon prevents division by zero."""
    # Volume is zero everywhere
    vol_zero = pd.Series([0.0] * 20)
    
    result = relative_volume(vol_zero, window=20)
    
    # Result should be 0.0 (0 / epsilon), not NaN or Inf
    assert result.iloc[-1] == pytest.approx(0.0)
    assert not np.isinf(result.iloc[-1])